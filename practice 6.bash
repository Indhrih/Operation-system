#!/bin/bash

# Переменные для хранения путей лог-файлов
LOG_FILE=""
ERROR_FILE=""

# Функция для вывода справки
show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

Options:
    -u, --users       Отображать пользователей и их домашние каталоги, отсортированные в алфавитном порядке.
    -p, --processes   Отображение запущенных процессов, отсортированных по PID.
    -l, --log PATH    Перенаправьте выходные данные в указанный файл журнала.
    -e, --errors PATH Перенаправьте stderr на указанный файл ошибок.
    -h, --help        Покажите это справочное сообщение и завершите работу.

Examples:
    $0 -u
    $0 -p -l /var/log/output.log -e /var/log/errors.log
EOF
}

# Функция для вывода пользователей и их домашних директорий
# Использует getent для получения информации о пользователях
# cut извлекает имя пользователя и домашнюю директорию
# sort сортирует результат по алфавиту
show_users() {
    getent passwd | cut -d: -f1,6 | sort
}

# Функция для вывода процессов, отсортированных по PID
# ps -e -o pid,ppid,cmd - отображает все процессы с выбранными полями
# --sort=pid сортирует процессы по идентификатору
show_processes() {
    ps -e -o pid,ppid,cmd --sort=pid
}

# Функция проверки доступа к файлу
# Проверяет возможность записи в файл и в родительскую директорию
# Параметры:
#   $1 - путь к файлу
#   $2 - тип файла (для сообщения об ошибке)
check_file_access() {
    local file=$1
    local type=$2

    # Проверяем, существует ли файл и доступен ли он для записи
    if [[ -e "$file" && ! -w "$file" ]]; then
        echo "Error: No write permission for $type file '$file'" >&2
        return 1
    fi

    # Получаем родительскую директорию файла
    local dir=$(dirname "$file")
    
    # Проверяем доступ на запись в родительскую директорию
    if [[ ! -w "$dir" ]]; then
        echo "Error: No write permission for directory '$dir'" >&2
        return 1
    fi

    return 0
}

# Парсинг аргументов командной строки с использованием getopt
# -o определяет короткие опции (u,p,l:,e:,h)
# --long определяет длинные опции
# -n "$0" - имя программы для сообщений об ошибках
# -- "$@" - передача всех аргументов командной строки
TEMP=$(getopt -o upl:e:h --long users,processes,log:,errors:,help -n "$0" -- "$@")

# Проверяем успешность парсинга аргументов
if [ $? -ne 0 ]; then
    show_help
    exit 1
fi

# eval set -- обрабатывает результат getopt
eval set -- "$TEMP"

# Инициализируем флаги команд
CMD_USERS=0
CMD_PROCESSES=0

# Обработка аргументов в цикле
while true; do
    case "$1" in
        -u|--users)
            CMD_USERS=1  # Устанавливаем флаг вывода пользователей
            shift
            ;;
        -p|--processes)
            CMD_PROCESSES=1  # Устанавливаем флаг вывода процессов
            shift
            ;;
        -l|--log)
            LOG_FILE="$2"  # Сохраняем путь для лог-файла
            shift 2  # Сдвигаем на 2 позиции (опция + значение)
            ;;
        -e|--errors)
            ERROR_FILE="$2"  # Сохраняем путь для файла ошибок
            shift 2  # Сдвигаем на 2 позиции (опция + значение)
            ;;
        -h|--help)
            show_help  # Выводим справку
            exit 0     # Завершаем работу после вывода справки
            ;;
        --)
            shift  # Конец опций
            break
            ;;
        *)
            echo "Internal error!" >&2
            exit 1
            ;;
    esac
done

# Перенаправление вывода ошибок (stderr) в файл
if [[ -n "$ERROR_FILE" ]]; then
    # Проверяем доступ к файлу ошибок
    if check_file_access "$ERROR_FILE" "error"; then
        # exec 2>> перенаправляет stderr в файл (>> для добавления)
        exec 2>>"$ERROR_FILE"
    else
        exit 1  # Завершаем работу при ошибке доступа
    fi
fi

# Перенаправление стандартного вывода (stdout) в файл
if [[ -n "$LOG_FILE" ]]; then
    # Проверяем доступ к лог-файлу
    if check_file_access "$LOG_FILE" "log"; then
        # exec 1>> перенаправляет stdout в файл (>> для добавления)
        exec 1>>"$LOG_FILE"
    else
        exit 1  # Завершаем работу при ошибке доступа
    fi
fi

# Выполнение команд в зависимости от установленных флагов

# Если установлен флаг вывода пользователей
if [[ $CMD_USERS -eq 1 ]]; then
    echo "=== User list ==="
    show_users  # Вызываем функцию показа пользователей
fi

# Если установлен флаг вывода процессов
if [[ $CMD_PROCESSES -eq 1 ]]; then
    echo "=== Process list ==="
    show_processes  # Вызываем функцию показа процессов
fi

# Если не указано никаких действий (ни пользователи, ни процессы)
if [[ $CMD_USERS -ne 1 && $CMD_PROCESSES -ne 1 ]]; then
    echo "Действие не указано. Используйте -h для получения справки." >&2
    exit 1
fi
